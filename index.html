<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Qualidade e Seguran√ßa</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>
    
    <style>
        :root {
            --cor-primaria: #01455C;
            --cor-secundaria: #9FC419;
            --cor-alerta: #ef4444;
            --cor-aviso: #f39c12;
            --cor-info: #3498db;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--cor-primaria);
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--cor-primaria);
            color: white;
            padding: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .filters {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-end;
        }
        
        .filter-group {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-color);
            font-size: 14px;
        }
        
        select, input {
            width: 100%;
            padding: 10px;
            border: 1.5px solid var(--cor-primaria);
            border-radius: 5px;
            background-color: var(--cor-primaria);
            font-size: 14px;
            box-sizing: border-box;
            color: white;
            font-weight: 700;
        }

        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .card-header {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: 700;
            color: var(--cor-primaria);
        }

        .card-subheader {
            font-size: 14px;
            color: #777;
            margin-top: -15px;
            margin-bottom: 20px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 20px;
            text-align: center;
            border-left: 5px solid var(--cor-primaria);
        }

        .stat-card.alerta { border-left-color: var(--cor-alerta); }
        .stat-card.sucesso { border-left-color: var(--cor-secundaria); }

        .stat-value {
            font-size: 32px;
            font-weight: 900;
            margin: 10px 0 5px 0;
        }
        
        .stat-value.primaria { color: var(--cor-primaria); }
        .stat-value.alerta { color: var(--cor-alerta); }
        .stat-value.sucesso { color: var(--cor-secundaria); }

        .stat-label {
            color: #777;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .chart-container {
            position: relative;
            width: 100%;
        }
        
        .tabs {
            border-bottom: 2px solid #dee2e6;
            margin-bottom: 20px;
        }
        .tab-link {
            padding: 10px 20px; cursor: pointer; border: none; background-color: transparent;
            color: white; font-size: 18px; font-weight: 600;
            border-bottom: 3px solid transparent; transition: all 0.3s ease;
        }
        .tab-link.active {
            color: var(--cor-secundaria);
            border-bottom-color: var(--cor-secundaria);
        }
        #scatter-legend-table {
            display: flex; justify-content: space-around; width: 100%;
            margin-top: 20px; font-size: 12px; color: black;
        }
        #scatter-legend-table h3 {
            font-weight: bold; color: var(--cor-primaria); border-bottom: 2px solid var(--cor-primaria);
            padding-bottom: 5px; margin-bottom: 10px;
        }
        #scatter-legend-table ol { list-style-position: inside; padding-left: 0; }
        #scatter-legend-table li { margin-bottom: 5px; display: flex; align-items: center; }
        #scatter-legend-table .legend-color-box {
            width: 12px; height: 12px; margin-right: 8px; border: 1px solid #ccc;
        }
        
        #inference-section {
            margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; color: black;
        }
        #inference-section > h3 {
            font-size: 1.5em; font-weight: 700; color: var(--cor-primaria);
            margin-bottom: 20px; text-align: center;
        }
        #inference-section .inference-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        #inference-section .inference-card {
            padding: 20px; border-radius: 8px; background-color: #f8f9fa;
            border-left: 5px solid #ccc;
        }
        #inference-section .inference-card.criticos { border-left-color: var(--cor-alerta); }
        #inference-section .inference-card.eficientes { border-left-color: var(--cor-secundaria); }
        #inference-section .inference-card.ineficientes { border-left-color: var(--cor-aviso); }
        
        #inference-section .inference-card-header {
            display: flex; align-items: center; margin-bottom: 12px;
        }
        #inference-section .inference-card-header svg {
            width: 32px; height: 32px; margin-right: 12px;
        }
        #inference-section .inference-card-header h4 {
            font-size: 1.1em; font-weight: 700; color: var(--dark-color);
        }
        #inference-section .inference-card p {
            font-size: 0.9em; color: #555; margin-bottom: 10px;
        }
        #inference-section .inference-tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .inference-category-tag {
            padding: 4px 10px; border-radius: 12px;
            font-size: 0.8em; font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .inference-card.criticos .inference-category-tag {
            background-color: var(--cor-alerta); color: white;
        }
        .inference-card.criticos .inference-category-tag:hover {
            background-color: #c0392b; transform: scale(1.05);
        }
        .inference-card.eficientes .inference-category-tag {
            background-color: var(--cor-secundaria); color: var(--dark-color);
        }
        .inference-card.eficientes .inference-category-tag:hover {
            background-color: #82a013; color: white; transform: scale(1.05);
        }
        .inference-card.ineficientes .inference-category-tag {
            background-color: var(--cor-aviso); color: white;
        }
        .inference-card.ineficientes .inference-category-tag:hover {
            background-color: #d35400; transform: scale(1.05);
        }

        #modal-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); display: none;
            justify-content: center; align-items: center; z-index: 1000;
        }
        #modal-content {
            background-color: white; color: black; padding: 25px;
            border-radius: 8px; width: 90%; max-width: 500px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #modal-title {
            font-size: 1.25em; font-weight: 600; color: var(--cor-primaria);
            margin: 0 0 15px 0; padding-bottom: 10px; border-bottom: 1px solid #eee;
        }
        #modal-body ol { list-style-position: inside; }
        #modal-body li { margin-bottom: 8px; }
        #modal-close-btn {
            background-color: var(--cor-primaria); color: white;
            border: none; padding: 10px 20px; border-radius: 5px;
            cursor: pointer; margin-top: 20px; float: right;
        }

        #progress-bar {
            transition: width 0.3s ease-in-out;
        }

        @media print {
            body { background-color: #fff !important; color: #000 !important; }
            header, footer, .tabs, .filters, #modal-container { display: none !important; }
            main#dashboard-content, .tab-content { display: block !important; }
            .card { box-shadow: none !important; border: 1px solid #ddd !important; page-break-inside: avoid !important; }
            .stat-card { border: 1px solid #ddd !important; }
            .chart-container { height: 350px !important; width: 100%; }
            h1.text-3xl { color: black !important; }
            #inference-section, #scatter-legend-table { color: black !important; }
            #inference-section .inference-card { background-color: #fff !important; }
        }
    </style>
</head>
<body class="text-gray-800 dark:text-gray-200 flex flex-col min-h-screen">

    <div class="flex-grow p-4 sm:p-6 lg:p-8">
        <header class="mb-8">
            <div class="container mx-auto flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-white dark:text-white">Dashboard de An√°lise de Apontamentos</h1>
                    <p class="text-gray-300 dark:text-gray-400">Relat√≥rio Interativo do SnagR</p>
                </div>
                <button id="print-button" class="bg-white text-gray-800 font-bold py-2 px-4 rounded shadow hover:bg-gray-200 transition-colors">
                    Imprimir Relat√≥rio
                </button>
            </div>
        </header>
        
        <div id="initial-message" class="initial-message text-center py-10 text-gray-200 text-lg">
            <p>Para come√ßar, arraste e solte um arquivo de dados na p√°gina ou carregue no rodap√©.</p>
        </div>
        
        <div id="loading-container" class="text-center py-10" style="display: none;">
            <p id="loading-status" class="text-gray-200 text-lg mb-4">Iniciando...</p>
            <div id="progress-bar-container" class="w-full max-w-md mx-auto bg-gray-600 rounded-full h-2.5">
                <div id="progress-bar" class="bg-[--cor-secundaria] h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>
        
        <div id="error-message" class="error bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" style="display: none;" role="alert"></div>

        <main id="dashboard-content" style="display: none;">
            <div class="tabs">
                <button class="tab-link active" onclick="openTab(event, 'visaoGeral')">Vis√£o Geral</button>
                <button class="tab-link" onclick="openTab(event, 'eficiencia')">Efici√™ncia (SLA)</button>
                <button class="tab-link" onclick="openTab(event, 'localizacao')">An√°lise por Localiza√ß√£o</button>
            </div>

            <div id="visaoGeral" class="tab-content">
                <div class="filters">
                    <div class="filter-group">
                        <label for="spotted-filter">Data (Spotted)</label>
                        <input type="date" id="spotted-filter">
                    </div>
                    <div class="filter-group">
                        <label for="year-filter">Ano</label>
                        <select id="year-filter">
                            <option value="all">Todos</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="month-filter">M√™s</label>
                        <select id="month-filter">
                            <option value="all">Todos</option>
                            <option value="0">Janeiro</option>
                            <option value="1">Fevereiro</option>
                            <option value="2">Mar√ßo</option>
                            <option value="3">Abril</option>
                            <option value="4">Maio</option>
                            <option value="5">Junho</option>
                            <option value="6">Julho</option>
                            <option value="7">Agosto</option>
                            <option value="8">Setembro</option>
                            <option value="9">Outubro</option>
                            <option value="10">Novembro</option>
                            <option value="11">Dezembro</option>
                        </select>
                    </div>
                </div>

                <div class="stats grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6">
                    <div class="stat-card"><div class="stat-label">Total</div><div class="stat-value primaria" id="total-records">0</div></div>
                    <div class="stat-card alerta"><div class="stat-label">Em Aberto</div><div class="stat-value alerta" id="open-records">0</div></div>
                    <div class="stat-card sucesso"><div class="stat-label">Fechados</div><div class="stat-value sucesso" id="closed-records">0</div></div>
                    <div class="stat-card sucesso"><div class="stat-label">Assinados</div><div class="stat-value sucesso" id="signed-off-records">0</div></div>
                    <div class="stat-card"><div class="stat-label">N√£o Aceitos</div><div class="stat-value primaria" id="not-accepted-records">0</div></div>
                    <div class="stat-card sucesso"><div class="stat-label">Taxa de Resolu√ß√£o</div><div class="stat-value sucesso" id="resolution-rate">0%</div></div>
                </div>

                <div class="card">
                    <div class="card-header">Volume de Apontamentos por M√™s</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="histogramChart"></canvas></div>
                </div>
                
                <div class="card">
                    <div class="card-header">Hist√≥rico de Taxa de Resolu√ß√£o (Mensal)</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="monthlyResolutionRateChart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-header">Hist√≥rico de Apontamentos por M√™s (Criados vs. Resolvidos)</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="statusHistoryChart"></canvas></div>
                </div>
                
                <div class="card">
                    <div class="card-header">An√°lise Detalhada por Descri√ß√£o</div>
                    <div class="filters" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); display: grid;">
                        <div class="filter-group"><label for="groupname-filter">Groupname</label><select id="groupname-filter"><option value="all">Todos</option></select></div>
                        <div class="filter-group"><label for="categoria-filter">Categoria</label><select id="categoria-filter"><option value="all">Todas</option></select></div>
                        <div class="filter-group"><label for="tipo-filter">Tipo</label><select id="tipo-filter"><option value="all">Todos</option></select></div>
                        <div class="filter-group"><label for="descricao-filter">Descri√ß√£o (Defeito)</label><select id="descricao-filter"><option value="all">Todas</option></select></div>
                    </div>
                    <div class="chart-container" style="height: 500px;"><canvas id="detailsChart"></canvas></div>
                </div>
                
                <div class="card">
                    <div class="card-header">Mapa de Calor: Concentra√ß√£o por Categoria/M√™s</div>
                     <div class="filters" style="padding: 0; box-shadow: none; margin-bottom: 15px;">
                         <div class="filter-group" style="min-width: 150px; max-width: 200px;">
                             <label for="heatmap-year-filter">Ano do Mapa de Calor</label>
                             <select id="heatmap-year-filter"><option value="all">Todos</option></select>
                         </div>
                     </div>
                    <div class="chart-container" style="height: 500px;"><canvas id="heatmapChart"></canvas></div>
                    <div id="heatmap-legend" class="mt-4 flex items-center justify-center space-x-2 text-sm text-gray-600"></div>
                </div>
            </div>

            <div id="eficiencia" class="tab-content" style="display: none;">
                <div class="card">
                    <div class="card-header">Desempenho de Resolu√ß√£o por Categoria</div>
                    <div class="card-subheader">(Eixo X = Tempo M√©dio de Resolu√ß√£o, Eixo Y = Volume de Apontamentos)</div>
                     <div class="chart-container" style="height: 450px;"><canvas id="resolutionScatterChart"></canvas></div>
                     <div id="scatter-legend-table"></div>
                     <div id="inference-section"></div>
                </div>
                 <div class="card mt-6">
                    <div class="card-header">Cumprimento de SLA por Categoria</div>
                     <div class="chart-container" style="height: 400px;"><canvas id="slaByCategoryChart"></canvas></div>
                </div>
            </div>

            <div id="localizacao" class="tab-content" style="display: none;">
                <div class="filters">
                    <div class="filter-group">
                        <label for="grouping-filter">Filtrar por Agrupamento (Torre/Setor)</label>
                        <select id="grouping-filter">
                            <option value="all">Todos</option>
                        </select>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">Volume de Apontamentos por Agrupamento</div>
                    <div class="card-subheader">Azul para Torre (T), Verde para Setor (S)</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="groupingVolumeChart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-header">Ranking de Locais por Volume de Apontamentos</div>
                    <div class="card-subheader">(Top 15 locais com maior incid√™ncia no agrupamento selecionado)</div>
                    <div class="chart-container" style="height: 500px;"><canvas id="locationRankingChart"></canvas></div>
                </div>
                
                <div class="card">
                    <div class="card-header">Mapa de Calor: Categoria vs. Local</div>
                    <div class="card-subheader">(Concentra√ß√£o de tipos de problema por local no agrupamento selecionado)</div>
                    <div class="chart-container" style="height: 600px;"><canvas id="locationCategoryHeatmap"></canvas></div>
                </div>
            </div>

        </main>
    </div>

    <footer class="bg-white dark:bg-gray-800 shadow-inner py-6 text-center">
        <div class="container mx-auto">
            <p class="text-gray-600 mb-4">Para atualizar os dados, selecione o arquivo <code class="bg-gray-200 p-1 rounded">.jsonl</code>.</p>
            <input type="file" id="json-file-input" accept=".jsonl,.txt,.json" style="display: none;" />
            <button class="bg-[--cor-primaria] hover:bg-blue-900 text-white font-bold py-2 px-4 rounded" onclick="document.getElementById('json-file-input').click()">Carregar Arquivo</button>
            <p id="file-name" style="margin-top: 10px; font-size: 14px; color: #555;"></p>
        </div>
    </footer>
    
    <div id="modal-container">
        <div id="modal-content">
            <h3 id="modal-title"></h3>
            <div id="modal-body"></div>
            <button id="modal-close-btn">Fechar</button>
        </div>
    </div>
    
    <div id="drag-drop-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(1, 69, 92, 0.85); z-index: 9999; display: none; justify-content: center; align-items: center; pointer-events: none;">
        <div style="border: 3px dashed var(--cor-secundaria); border-radius: 15px; padding: 40px 60px; text-align: center;">
            <h2 style="color: white; font-size: 2em; font-weight: bold;">Solte o arquivo .jsonl aqui</h2>
            <p style="color: var(--light-color); font-size: 1.1em;">O processamento ser√° iniciado automaticamente.</p>
        </div>
    </div>


    <script>
        // ### VARI√ÅVEIS GLOBAIS E DE ESTADO ###
        let allData = []; // Armazena todos os dados brutos processados do arquivo
        let currentFinalData = []; // Armazena os dados filtrados atualmente exibidos nos gr√°ficos
        let histogramChart, detailsChart, heatmapChart, slaByCategoryChart, monthlyResolutionRateChart, resolutionScatterChart, statusHistoryChart;
        let locationRankingChart, locationCategoryHeatmap, groupingVolumeChart;
        // Regras de SLA (Service Level Agreement) por prioridade
        const SLA_RULES = { 1: 3, 2: 7, 3: 15, 4: 30 }; // Prioridade: Dias

        // ### PROCESSAMENTO E NORMALIZA√á√ÉO DE DADOS ###
        
        const processAndNormalizeData = (rawData) => {
            return rawData.map(item => {
                if (!item.SnagID) return null;
                let spottedDate = item.Spotted?.split('T')[0];
                let fixDate = item['Data altera√ß√£o']?.split('T')[0];
                let lastChangedDate = item['Data altera√ß√£o']?.split('T')[0];
                let finalStatus = item.Status;
                if (item.FixStatus?.toLowerCase() === 'signedoff') finalStatus = 'SignedOff';
                if (item.FixStatus?.toLowerCase() === 'notadefect') finalStatus = 'NotADefect';
                let daysToResolve = null;
                if ((finalStatus === 'Closed' || finalStatus === 'SignedOff') && spottedDate && fixDate) {
                    const start = new Date(spottedDate);
                    const end = new Date(fixDate);
                    if (!isNaN(start) && !isNaN(end)) {
                        daysToResolve = (end - start) / (1000 * 60 * 60 * 24);
                    }
                }
                const sla = SLA_RULES[item.Priority];
                const withinSla = daysToResolve !== null && sla !== undefined ? daysToResolve <= sla : null;
                
                const location = item.Location || "N√£o definido";
                let agrupamento = "N/A";
                let tipoAgrupamento = "Outro";
                let pavimento = location; 

                const match = location.match(/^(T|S)0?([1-5])_?/i);

                if (match) {
                    const typeChar = match[1].toUpperCase(); 
                    const number = match[2];
                    
                    if (typeChar === 'T') {
                        tipoAgrupamento = "Torre";
                        agrupamento = `Torre 0${number}`;
                    } else if (typeChar === 'S') {
                        tipoAgrupamento = "Setor";
                        agrupamento = `Setor 0${number}`;
                    }
                    pavimento = location.substring(match[0].length).trim();
                }

                return {
                    id: item.SnagID,
                    responsavel: item.Fullname || "N√£o atribu√≠do",
                    data: spottedDate,
                    lastChangedDate: lastChangedDate,
                    tipo: item.Description || "N√£o definido",
                    categoria: item.Category || "N√£o definida",
                    descricao: item.Defect || "N√£o definido",
                    situacao: finalStatus || "N√£o definida",
                    groupname: item.Groupname || "N√£o definido",
                    priority: item.Priority,
                    daysToResolve: daysToResolve,
                    withinSla: withinSla,
                    Location: location,
                    Agrupamento: agrupamento,
                    TipoAgrupamento: tipoAgrupamento,
                    Pavimento: pavimento
                };
            }).filter(item => item !== null);
        };
        
        const processDataInChunks = async (rawData, onProgress) => {
            const chunkSize = 1000;
            let processedData = [];
            for (let i = 0; i < rawData.length; i += chunkSize) {
                const chunk = rawData.slice(i, i + chunkSize);
                
                const processedChunk = processAndNormalizeData(chunk);
                processedData = processedData.concat(processedChunk);
                
                const progress = Math.round(((i + chunk.length) / rawData.length) * 100);
                onProgress(progress);

                await new Promise(resolve => setTimeout(resolve, 0)); 
            }
            return processedData;
        };

        const getUniqueRecords = (data) => {
            const seenIds = new Set();
            return data.filter(item => {
                if (seenIds.has(item.id)) return false;
                seenIds.add(item.id);
                return true;
            });
        };
        
        /**
         * Processa o conte√∫do de texto de um arquivo.
         */
        const processContent = async (content, fileName) => {
            const loadingContainer = document.getElementById('loading-container');
            const statusText = document.getElementById('loading-status');
            const progressBar = document.getElementById('progress-bar');
            
            try {
                statusText.textContent = 'Leitura conclu√≠da. Processando dados...';
                progressBar.style.width = '50%';
                
                // Determina o nome real do arquivo para exibi√ß√£o (remove caminho se houver)
                const displayFileName = fileName.includes('/') ? fileName.split('/').pop() : fileName;

                let rawData = (fileName.endsWith('.jsonl'))
                    ? content.split('\n').filter(Boolean).map(line => JSON.parse(line.replace(/:\s*NaN/g, ': null')))
                    : JSON.parse(content.replace(/:\s*NaN/g, ': null'));

                allData = await processDataInChunks(rawData, (progress) => {
                    const totalProgress = 50 + (progress / 2);
                    statusText.textContent = `Processando dados... ${progress}%`;
                    progressBar.style.width = `${totalProgress}%`;
                });

                if (allData.length === 0) {
                    showError("O arquivo n√£o cont√©m dados de apontamentos v√°lidos.");
                    loadingContainer.style.display = 'none';
                    return;
                }

                statusText.textContent = 'Gerando gr√°ficos...';
                document.getElementById('file-name').textContent = `Arquivo: ${displayFileName}`;
                populateGlobalFilters();
                populateHeatmapYearFilter(allData);
                runUpdate();
                
                loadingContainer.style.display = 'none';
                document.getElementById('dashboard-content').style.display = 'block';

            } catch (err) {
                showError(`Erro ao processar o arquivo ${fileName}. Detalhe: ${err.message}`);
                loadingContainer.style.display = 'none';
            }
        };

        /**
         * Processa um arquivo carregado pelo usu√°rio.
         */
        const processFile = async (file) => {
            if (!file) return;

            if (!file.name.endsWith('.jsonl') && !file.name.endsWith('.txt') && !file.name.endsWith('.json')) {
                showError('Por favor, carregue um arquivo v√°lido (.jsonl, .json ou .txt).');
                return;
            }

            const loadingContainer = document.getElementById('loading-container');
            const statusText = document.getElementById('loading-status');
            const progressBar = document.getElementById('progress-bar');
            
            document.getElementById('file-name').textContent = `Arquivo: ${file.name}`;
            ['initial-message', 'dashboard-content', 'error-message'].forEach(id => document.getElementById(id).style.display = 'none');
            statusText.textContent = 'Lendo arquivo...';
            progressBar.style.width = '0%';
            loadingContainer.style.display = 'block';

            if (locationRankingChart) locationRankingChart.destroy();
            if (locationCategoryHeatmap) locationCategoryHeatmap.destroy();
            if (groupingVolumeChart) groupingVolumeChart.destroy();

            const reader = new FileReader();

            reader.onprogress = (event) => {
                if (event.lengthComputable) {
                    const percentage = Math.round((event.loaded / event.total) * 50);
                    statusText.textContent = `Lendo arquivo... ${percentage * 2}%`;
                    progressBar.style.width = `${percentage}%`;
                }
            };

            reader.onload = async (e) => {
                await processContent(e.target.result, file.name);
            };

            reader.onerror = () => {
                showError('N√£o foi poss√≠vel ler o arquivo.');
                loadingContainer.style.display = 'none';
            };

            reader.readAsText(file);
        };

        /**
         * *** MUDAN√áA: Fun√ß√£o loadDefaultFile SIMPLIFICADA para usar fetch direto no .jsonl ***
         * Carrega o arquivo .jsonl padr√£o do Asset da Release.
         */
        const loadDefaultFile = async (jsonlUrl) => {
            const loadingContainer = document.getElementById('loading-container');
            const statusText = document.getElementById('loading-status');
            const progressBar = document.getElementById('progress-bar');

            ['initial-message', 'dashboard-content', 'error-message'].forEach(id => document.getElementById(id).style.display = 'none');
            statusText.textContent = `Carregando arquivo padr√£o...`;
            progressBar.style.width = '10%'; 
            loadingContainer.style.display = 'block';
            
            if (locationRankingChart) locationRankingChart.destroy();
            if (locationCategoryHeatmap) locationCategoryHeatmap.destroy();
            if (groupingVolumeChart) groupingVolumeChart.destroy();

            try {
                // 1. Baixar o arquivo .jsonl como texto
                statusText.textContent = 'Baixando arquivo...';
                const response = await fetch(jsonlUrl);
                if (!response.ok) {
                    throw new Error(`Arquivo n√£o encontrado (HTTP ${response.status})`);
                }
                progressBar.style.width = '25%'; // Atualiza progresso ap√≥s download

                // 2. Obter o conte√∫do como texto
                const content = await response.text();
                
                // 3. Extrair o nome do arquivo da URL para exibi√ß√£o
                const fileName = jsonlUrl.split('/').pop(); 
                statusText.textContent = `Arquivo baixado (${fileName}). Processando...`;
                progressBar.style.width = '40%';

                // 4. Enviar o conte√∫do de texto para a fun√ß√£o de processamento existente
                await processContent(content, fileName); 

            } catch (err) {
                console.error(`Falha ao carregar arquivo padr√£o: ${err.message}`);
                loadingContainer.style.display = 'none';
                document.getElementById('initial-message').style.display = 'block';
                document.getElementById('file-name').textContent = `Falha ao carregar ${jsonlUrl}. Detalhe: ${err.message}. Carregue um arquivo manual.`; 
            }
        };


        const handleFileUpload = (event) => {
            const file = event.target.files[0];
            processFile(file);
        };
        
        const runUpdate = () => {
            if (allData.length === 0) return;
            const selectedSpottedDate = document.getElementById('spotted-filter').value;
            const selectedYear = document.getElementById('year-filter').value;
            const selectedMonth = document.getElementById('month-filter').value;
            let baseFilteredData = allData;
            if (selectedSpottedDate) {
                baseFilteredData = baseFilteredData.filter(d => d.data === selectedSpottedDate);
            }
            if (selectedYear !== 'all') {
                const yearNumber = parseInt(selectedYear, 10);
                const today = new Date();
                const currentYear = today.getFullYear();
                today.setHours(0, 0, 0, 0);
                baseFilteredData = baseFilteredData.filter(d => {
                    if (!d.data) return false;
                    const recordDate = new Date(d.data);
                    if (recordDate.getFullYear() !== yearNumber) return false;
                    if (yearNumber === currentYear && recordDate > today) return false;
                    return true;
                });
            }
            if (selectedMonth !== 'all') {
                const monthNumber = parseInt(selectedMonth, 10);
                baseFilteredData = baseFilteredData.filter(d => {
                    if (!d.data) return false;
                    const recordDate = new Date(d.data);
                    return recordDate.getMonth() === monthNumber;
                });
            }
            
            const uniqueBaseFilteredData = getUniqueRecords(baseFilteredData);
            
            updateDetailFilters(uniqueBaseFilteredData);
            const selectedGroupname = document.getElementById('groupname-filter').value;
            const selectedCategoria = document.getElementById('categoria-filter').value;
            const selectedTipo = document.getElementById('tipo-filter').value;
            const selectedDescricao = document.getElementById('descricao-filter').value;
            let finalFilteredData = uniqueBaseFilteredData;
            if (selectedGroupname !== 'all') finalFilteredData = finalFilteredData.filter(d => d.groupname === selectedGroupname);
            if (selectedCategoria !== 'all') finalFilteredData = finalFilteredData.filter(d => d.categoria === selectedCategoria);
            if (selectedTipo !== 'all') finalFilteredData = finalFilteredData.filter(d => d.tipo === selectedTipo);
            if (selectedDescricao !== 'all') finalFilteredData = finalFilteredData.filter(d => d.descricao === selectedDescricao);
            
            currentFinalData = finalFilteredData;

            updateKPIs(uniqueBaseFilteredData);
            updateHistogramChart(uniqueBaseFilteredData);
            updateDetailsChart(finalFilteredData);
            updateHeatmapChart(uniqueBaseFilteredData);
            updateMonthlyResolutionRateChart(uniqueBaseFilteredData);
            
            updateStatusHistoryChart(getUniqueRecords(allData), selectedYear, selectedMonth);

            updateResolutionScatterChart(finalFilteredData);
            updateSlaByCategoryChart(finalFilteredData);

            populateGroupingFilter(finalFilteredData);
            updateGroupingVolumeChart(finalFilteredData);

            const selectedGrouping = document.getElementById('grouping-filter').value;
            let locationFilteredData = finalFilteredData;
            if(selectedGrouping !== 'all') {
                locationFilteredData = finalFilteredData.filter(d => d.Agrupamento === selectedGrouping);
            }

            updateLocationRankingChart(locationFilteredData);
            updateLocationCategoryHeatmap(locationFilteredData);
        };
        
        const updateDetailFilters = (data) => {
            const groupnamesUnicos = [...new Set(data.map(item => item.groupname))].filter(Boolean);
            populateDropdown('groupname-filter', groupnamesUnicos, document.getElementById('groupname-filter').value);
            const dataFiltradaPorGrupo = document.getElementById('groupname-filter').value === 'all' ? data : data.filter(d => d.groupname === document.getElementById('groupname-filter').value);
            const categoriasUnicas = [...new Set(dataFiltradaPorGrupo.map(item => item.categoria))].filter(Boolean);
            populateDropdown('categoria-filter', categoriasUnicas, document.getElementById('categoria-filter').value);
            const dataFiltradaPorCategoria = document.getElementById('categoria-filter').value === 'all' ? dataFiltradaPorGrupo : dataFiltradaPorGrupo.filter(d => d.categoria === document.getElementById('categoria-filter').value);
            const tiposUnicos = [...new Set(dataFiltradaPorCategoria.map(item => item.tipo))].filter(Boolean);
            populateDropdown('tipo-filter', tiposUnicos, document.getElementById('tipo-filter').value);
            const dataFiltradaPorTipo = document.getElementById('tipo-filter').value === 'all' ? dataFiltradaPorCategoria : dataFiltradaPorCategoria.filter(d => d.tipo === document.getElementById('tipo-filter').value);
            const descricoesUnicas = [...new Set(dataFiltradaPorTipo.map(item => item.descricao))].filter(Boolean);
            populateDropdown('descricao-filter', descricoesUnicas, document.getElementById('descricao-filter').value);
        };
        
        const populateDropdown = (elementId, options, selectedValue = 'all') => {
            const select = document.getElementById(elementId);
            const currentValue = select.value;
            while (select.options.length > 1) select.remove(1);
            options.sort().forEach(optionValue => select.add(new Option(optionValue, optionValue)));
            select.value = [...select.options].some(opt => opt.value === currentValue) ? currentValue : 'all';
        };

        const populateGlobalFilters = () => {
            const years = [...new Set(allData.map(item => item.data ? new Date(item.data).getFullYear() : null))].filter(Boolean);
            populateDropdown('year-filter', years.sort((a, b) => b - a));
        };

        const populateHeatmapYearFilter = (data) => {
            const years = [...new Set(data.map(item => item.data ? new Date(item.data).getFullYear() : null))].filter(Boolean);
            populateDropdown('heatmap-year-filter', years.sort((a, b) => b - a));
        };
        
        const populateGroupingFilter = (data) => {
            const groupings = [...new Set(data.map(item => item.Agrupamento))].filter(g => g !== 'N/A');
            populateDropdown('grouping-filter', groupings);
        };

        const updateKPIs = (data) => {
            const totalCount = data.length;
            document.getElementById('total-records').textContent = totalCount;
            document.getElementById('open-records').textContent = data.filter(d => d.situacao?.toLowerCase() === 'open').length;
            const closedCount = data.filter(d => d.situacao?.toLowerCase() === 'closed').length;
            const signedOffCount = data.filter(d => d.situacao?.toLowerCase() === 'signedoff').length;
            document.getElementById('closed-records').textContent = closedCount;
            document.getElementById('signed-off-records').textContent = signedOffCount;
            document.getElementById('not-accepted-records').textContent = data.filter(d => d.situacao?.toLowerCase() === 'notadefect').length;
            const resolvedCount = closedCount + signedOffCount;
            const resolutionRate = totalCount > 0 ? ((resolvedCount / totalCount) * 100).toFixed(1) : 0;
            document.getElementById('resolution-rate').textContent = `${resolutionRate}%`;
        };

        const updateHistogramChart = (data) => {
            const ctx = document.getElementById('histogramChart').getContext('2d');
            const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const monthlyCounts = Array(12).fill(0);
            data.forEach(item => {
                if (item.data) {
                    const month = new Date(item.data).getMonth();
                    if (month >= 0 && month < 12) monthlyCounts[month]++;
                }
            });
            if (histogramChart) histogramChart.destroy();
            histogramChart = new Chart(ctx, { type: 'bar', data: { labels: months, datasets: [{ label: 'Apontamentos', data: monthlyCounts, backgroundColor: 'rgba(1, 70, 92, 0.7)', borderColor: 'rgba(1, 70, 92, 1)', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }, plugins: { legend: { display: false } } } });
        };
        
        const updateMonthlyResolutionRateChart = (data) => {
            const ctx = document.getElementById('monthlyResolutionRateChart').getContext('2d');
            const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const monthlyTotals = Array(12).fill(0);
            const monthlyResolved = Array(12).fill(0);
            data.forEach(item => {
                if (item.data) {
                    const month = new Date(item.data).getMonth();
                    if (month >= 0 && month < 12) {
                        monthlyTotals[month]++;
                        if (['closed', 'signedoff'].includes(item.situacao?.toLowerCase())) {
                            monthlyResolved[month]++;
                        }
                    }
                }
            });
            const resolutionRates = monthlyTotals.map((total, index) => total > 0 ? (monthlyResolved[index] / total) * 100 : 0);
            if (monthlyResolutionRateChart) monthlyResolutionRateChart.destroy();
            monthlyResolutionRateChart = new Chart(ctx, { type: 'line', data: { labels: months, datasets: [{ label: 'Taxa de Resolu√ß√£o', data: resolutionRates, backgroundColor: 'rgba(159, 196, 25, 0.2)', borderColor: 'rgba(159, 196, 25, 1)', borderWidth: 2, fill: true, tension: 0.3 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: 100, ticks: { callback: (value) => `${value}%` } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (context) => ` Taxa: ${context.raw.toFixed(2)}%` } } } } });
        };
        
        const updateStatusHistoryChart = (data, selectedYear, selectedMonth) => {
            const ctx = document.getElementById('statusHistoryChart').getContext('2d');
            const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            
            const today = new Date();
            today.setHours(23, 59, 59, 999);

            const monthlyCreated = Array(12).fill(0);
            data.forEach(item => {
                if (item.data) {
                    const recordDate = new Date(item.data);
                    if (isNaN(recordDate.getTime()) || recordDate > today) return;

                    if (selectedYear !== 'all' && recordDate.getFullYear() != selectedYear) return;
                    if (selectedMonth !== 'all' && recordDate.getMonth() != selectedMonth) return;
                    
                    const monthIndex = recordDate.getMonth();
                    monthlyCreated[monthIndex]++;
                }
            });

            const monthlyResolved = Array(12).fill(0);
            data.forEach(item => {
                const status = item.situacao?.toLowerCase();
                if (item.lastChangedDate && (status === 'assigned' || status === 'closed' || status === 'signedoff')) {
                    const resolvedDate = new Date(item.lastChangedDate);
                    if (isNaN(resolvedDate.getTime()) || resolvedDate > today) return;

                    if (selectedYear !== 'all' && resolvedDate.getFullYear() != selectedYear) return;
                    if (selectedMonth !== 'all' && resolvedDate.getMonth() != selectedMonth) return;

                    const monthIndex = resolvedDate.getMonth();
                    monthlyResolved[monthIndex]++;
                }
            });

            if (statusHistoryChart) statusHistoryChart.destroy();

            statusHistoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: months,
                    datasets: [
                        {
                            label: 'Criados no M√™s',
                            data: monthlyCreated,
                            backgroundColor: 'rgba(239, 68, 68, 0.7)',
                            borderColor: 'rgba(239, 68, 68, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Resolvidos no M√™s',
                            data: monthlyResolved,
                            backgroundColor: 'rgba(159, 196, 25, 0.7)',
                            borderColor: 'rgba(159, 196, 25, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { stacked: false },
                        y: { beginAtZero: true, ticks: { precision: 0 }, stacked: false }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: { mode: 'index', intersect: false }
                    }
                }
            });
        };

        const updateDetailsChart = (data) => {
            const ctx = document.getElementById('detailsChart').getContext('2d');
            const descriptionCounts = data.reduce((acc, item) => {
                const key = item.descricao || "N√£o definido";
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});
            const sortedData = Object.entries(descriptionCounts).sort(([, a], [, b]) => b - a).slice(0, 15);
            const labels = sortedData.map(item => item[0]);
            const values = sortedData.map(item => item[1]);
            if (detailsChart) detailsChart.destroy();
            detailsChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Contagem', data: values, backgroundColor: 'rgba(159, 196, 25, 0.7)', borderColor: 'rgba(159, 196, 25, 1)', borderWidth: 1 }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, scales: { x: { beginAtZero: true, ticks: { precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: context => ` Apontamentos: ${context.raw}` } } } } });
        };
        
        const updateHeatmapChart = (data) => {
            const selectedYear = document.getElementById('heatmap-year-filter').value;
            let chartData = data;
            if (selectedYear !== 'all') {
                const yearNumber = parseInt(selectedYear, 10);
                const today = new Date();
                const currentYear = today.getFullYear();
                today.setHours(0, 0, 0, 0);
                chartData = data.filter(d => {
                    if (!d.data) return false;
                    const recordDate = new Date(d.data);
                    if (recordDate.getFullYear() !== yearNumber) return false;
                    if (yearNumber === currentYear && recordDate > today) return false;
                    return true;
                });
            }
            const ctx = document.getElementById('heatmapChart').getContext('2d');
            const monthLabels = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const categoryCounts = {};
            chartData.forEach(item => {
                if (item.data && item.categoria) {
                    const category = item.categoria;
                    const monthIndex = new Date(item.data).getMonth();
                    if (monthIndex >= 0 && monthIndex < 12) {
                        const month = monthLabels[monthIndex];
                        if (!categoryCounts[category]) categoryCounts[category] = {};
                        categoryCounts[category][month] = (categoryCounts[category][month] || 0) + 1;
                    }
                }
            });
            const heatmapData = [];
            let maxValue = 0;
            const categoryLabels = Object.keys(categoryCounts).sort();
            categoryLabels.forEach(category => {
                monthLabels.forEach(month => {
                    const value = categoryCounts[category]?.[month] || 0;
                    if (value > 0) heatmapData.push({ x: month, y: category, v: value });
                    if (value > maxValue) maxValue = value;
                });
            });
            if (heatmapChart) heatmapChart.destroy();
            heatmapChart = new Chart(ctx, { type: 'matrix', data: { datasets: [{ label: 'Apontamentos', data: heatmapData, backgroundColor: (context) => { const value = context.dataset.data[context.dataIndex]?.v; if (!value) return 'rgba(245, 245, 245, 0.5)'; const alpha = value / maxValue; return `rgba(1, 70, 92, ${alpha})`; }, borderColor: 'white', borderWidth: 1, width: ({ chart }) => (chart.chartArea || {}).width / monthLabels.length - 1, height: ({ chart }) => (chart.chartArea || {}).height / categoryLabels.length - 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'category', labels: monthLabels }, y: { type: 'category', labels: categoryLabels, offset: true } }, plugins: { legend: { display: false }, tooltip: { callbacks: { title: () => '', label: (context) => { const v = context.dataset.data[context.dataIndex]; return `${v.y} em ${v.x}: ${v.v} apontamentos`; } } } } } });
            const legendContainer = document.getElementById('heatmap-legend');
            legendContainer.innerHTML = '';
            if (maxValue > 0) {
                const gradient = 'linear-gradient(to right, rgba(1, 70, 92, 0.05), rgba(1, 70, 92, 1))';
                legendContainer.innerHTML = `<span>Baixa (1)</span><div style="width: 150px; height: 20px; background: ${gradient}; border-radius: 5px; margin: 0 10px;"></div><span>Alta (${maxValue})</span>`;
            }
        };
        
        const updateResolutionScatterChart = (data) => {
            const ctx = document.getElementById('resolutionScatterChart').getContext('2d');
            const statsByCategory = {};
            data.forEach(item => {
                if (item.daysToResolve !== null && item.categoria) {
                    if (!statsByCategory[item.categoria]) {
                        statsByCategory[item.categoria] = { totalDays: 0, count: 0 };
                    }
                    statsByCategory[item.categoria].totalDays += item.daysToResolve;
                    statsByCategory[item.categoria].count++;
                }
            });
            const scatterData = Object.keys(statsByCategory).map(category => {
                const stats = statsByCategory[category];
                const avgDays = stats.count > 0 ? (stats.totalDays / stats.count) : 0;
                return { x: avgDays, y: stats.count, label: category };
            }).filter(d => d.y > 0);
            const legendContainer = document.getElementById('scatter-legend-table');
            const inferenceContainer = document.getElementById('inference-section');
            if (resolutionScatterChart) resolutionScatterChart.destroy();
            if (scatterData.length === 0) {
                 legendContainer.innerHTML = '';
                 inferenceContainer.innerHTML = '';
                 return;
            }
            const avgDaysValues = scatterData.map(d => d.x);
            const minAvg = Math.min(...avgDaysValues);
            const maxAvg = Math.max(...avgDaysValues);
            const getColorForTime = (value) => {
                if (maxAvg === minAvg) return 'rgb(159, 196, 25)';
                const ratio = (value - minAvg) / (maxAvg - minAvg);
                const r = Math.round(159 + (1 - 159) * ratio);
                const g = Math.round(196 + (69 - 196) * ratio);
                const b = Math.round(25 + (92 - 25) * ratio);
                return `rgb(${r}, ${g}, ${b})`;
            };
            scatterData.forEach(d => d.color = getColorForTime(d.x));
            resolutionScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{ data: scatterData, pointBackgroundColor: context => context.raw.color, pointRadius: 8, pointHoverRadius: 12, borderWidth: 0 }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { beginAtZero: true, title: { display: true, text: 'Tempo M√©dio de Resolu√ß√£o (Dias)'}},
                        y: { beginAtZero: true, title: { display: true, text: 'Volume de Apontamentos Resolvidos' }}
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { label: (context) => { const point = context.raw; return [`${point.label}`, `Volume: ${point.y}`, `Tempo M√©dio: ${point.x.toFixed(1)} dias`]; } } }
                    }
                }
            });
            const top10Volume = [...scatterData].sort((a, b) => b.y - a.y).slice(0, 10);
            const top10Time = [...scatterData].sort((a, b) => b.x - a.x).slice(0, 10);
            const generateListHTML = (title, items, metric) => {
                let listItems = items.map(item => `<li><div class="legend-color-box" style="background-color: ${item.color};"></div><div>${item.label} (${metric === 'volume' ? `${item.y} apont.` : `${item.x.toFixed(1)} dias`})</div></li>`).join('');
                return `<div class="px-4"><h3>${title}</h3><ol>${listItems}</ol></div>`;
            };
            legendContainer.innerHTML = generateListHTML('Top 10 por Volume', top10Volume, 'volume') + generateListHTML('Top 10 por Tempo de Resolu√ß√£o', top10Time, 'time');
            
            if (scatterData.length < 2) {
                inferenceContainer.innerHTML = `
                    <h3>Infer√™ncia Estat√≠stica e Plano de A√ß√£o</h3>
                    <p style="text-align:center; color: #555; padding: 20px 0;">
                        A an√°lise de quadrantes requer a compara√ß√£o entre m√∫ltiplas categorias. Com apenas uma categoria vis√≠vel, n√£o √© poss√≠vel gerar uma infer√™ncia comparativa.
                    </p>
                `;
            } else {
                const avgX = avgDaysValues.reduce((a, b) => a + b, 0) / avgDaysValues.length;
                const avgY = scatterData.map(d => d.y).reduce((a, b) => a + b, 0) / scatterData.length;
                const quadrants = {
                    criticos: scatterData.filter(d => d.x > avgX && d.y > avgY).sort((a,b) => b.y - a.y),
                    eficientes: scatterData.filter(d => d.x <= avgX && d.y > avgY).sort((a,b) => b.y - a.y),
                    ineficientes: scatterData.filter(d => d.x > avgX && d.y <= avgY).sort((a,b) => b.x - a.x)
                };
                const ICON_CRITICO = `<svg xmlns="http://www.w3.org/2000/svg" fill="var(--cor-alerta)" viewBox="0 0 24 24" stroke-width="1.5" stroke="white"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`;
                const ICON_EFICIENTE = `<svg xmlns="http://www.w3.org/2000/svg" fill="var(--cor-secundaria)" viewBox="0 0 24 24" stroke-width="1.5" stroke="white"><path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.82m5.84-2.56a14.96 14.96 0 00-5.84-2.56m0 0a14.96 14.96 0 01-5.84-2.56m5.84 2.56v-4.82m0 0a6 6 0 00-5.84-7.38v4.82m5.84 2.56h4.82a6 6 0 01-7.38 5.84m0 0a6 6 0 00-7.38-5.84h4.82" /></svg>`;
                const ICON_INEFICIENTE = `<svg xmlns="http://www.w3.org/2000/svg" fill="var(--cor-aviso)" viewBox="0 0 24 24" stroke-width="1.5" stroke="white"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
                
                const generateInferenceHTML = (title, description, categories, iconSvg, quadrantClass) => {
                    if (categories.length === 0) return '';
                    const items = categories.map(cat => `<span class="inference-category-tag" onclick="showDefectDetails('${cat.label.replace(/'/g, "\\'")}')">${cat.label}</span>`).join('');
                    return `
                        <div class="inference-card ${quadrantClass}">
                            <div class="inference-card-header">
                                ${iconSvg}
                                <h4>${title}</h4>
                            </div>
                            <p>${description}</p>
                            <div class="inference-tag-container">${items}</div>
                        </div>
                    `;
                };
                inferenceContainer.innerHTML = `
                    <h3>Infer√™ncia Estat√≠stica e Plano de A√ß√£o</h3>
                    <div class="inference-grid">
                        ${generateInferenceHTML('Pontos Cr√≠ticos', 'Alto volume e alta demora. Estas categorias s√£o as mais problem√°ticas e requerem aten√ß√£o priorit√°ria.', quadrants.criticos, ICON_CRITICO, 'criticos')}
                        ${generateInferenceHTML('Pontos de Inefici√™ncia', 'Baixo volume, mas alta demora. Sugere-se revisar o processo ou treinamento espec√≠fico para estas tarefas.', quadrants.ineficientes, ICON_INEFICIENTE, 'ineficientes')}
                        ${generateInferenceHTML('Pontos Eficientes', 'Alto volume e baixa demora. Estas categorias podem servir como modelo de boas pr√°ticas para outras √°reas.', quadrants.eficientes, ICON_EFICIENTE, 'eficientes')}
                    </div>
                `;
            }
        };

        const updateSlaByCategoryChart = (data) => {
            const ctx = document.getElementById('slaByCategoryChart').getContext('2d');
            const slaByCategory = {};
            [...new Set(data.map(item => item.categoria))].filter(Boolean).forEach(cat => {
                slaByCategory[cat] = { total: 0, withinSla: 0 };
            });
            data.forEach(item => {
                if (item.withinSla !== null && item.categoria) {
                    slaByCategory[item.categoria].total++;
                    if (item.withinSla) slaByCategory[item.categoria].withinSla++;
                }
            });
            const labels = Object.keys(slaByCategory).sort();
            const complianceData = labels.map(cat => {
                const item = slaByCategory[cat];
                return item.total > 0 ? ((item.withinSla / item.total) * 100) : 0;
            });
            if (slaByCategoryChart) slaByCategoryChart.destroy();
            slaByCategoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '% Dentro do SLA',
                        data: complianceData,
                        backgroundColor: 'rgba(159, 196, 25, 0.7)'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { x: { beginAtZero: true, max: 100 } },
                    plugins: { legend: { display: false } }
                }
            });
        };
        
        const updateGroupingVolumeChart = (data) => {
            const ctx = document.getElementById('groupingVolumeChart').getContext('2d');
            const groupingCounts = data.reduce((acc, item) => {
                const key = item.Agrupamento;
                if(key !== "N/A") {
                    if (!acc[key]) {
                        acc[key] = { count: 0, type: item.TipoAgrupamento };
                    }
                    acc[key].count++;
                }
                return acc;
            }, {});

            const sortedData = Object.entries(groupingCounts).sort(([, a], [, b]) => b.count - a.count);
            const labels = sortedData.map(item => item[0]);
            const values = sortedData.map(item => item[1].count);
            
            const backgroundColors = sortedData.map(item => {
                const type = item[1].type;
                if (type === 'Torre') return 'rgba(1, 70, 92, 0.8)'; // Cor Prim√°ria
                if (type === 'Setor') return 'rgba(159, 196, 25, 0.8)'; // Cor Secund√°ria
                return 'rgba(128, 128, 128, 0.8)';
            });

            if (groupingVolumeChart) groupingVolumeChart.destroy();

            groupingVolumeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Volume por Agrupamento',
                        data: values,
                        backgroundColor: backgroundColors
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: true, ticks: { precision: 0 } } },
                    plugins: { legend: { display: false } }
                }
            });
        };

        const updateLocationRankingChart = (data) => {
            const ctx = document.getElementById('locationRankingChart').getContext('2d');
            
            const locationCounts = data.reduce((acc, item) => {
                const key = item.Location || "N√£o definido";
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sortedData = Object.entries(locationCounts).sort(([, a], [, b]) => b - a).slice(0, 15);
            const labels = sortedData.map(item => item[0]);
            const values = sortedData.map(item => item[1]);

            if (locationRankingChart) locationRankingChart.destroy();
            
            locationRankingChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'N¬∫ de Apontamentos',
                        data: values,
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { x: { beginAtZero: true, ticks: { precision: 0 } } },
                    plugins: { legend: { display: false } }
                }
            });
        };

        const updateLocationCategoryHeatmap = (data) => {
            const ctx = document.getElementById('locationCategoryHeatmap').getContext('2d');

            const counts = {};
            data.forEach(item => {
                if (item.Location && item.categoria) {
                    if (!counts[item.Location]) counts[item.Location] = {};
                    counts[item.Location][item.categoria] = (counts[item.Location][item.categoria] || 0) + 1;
                }
            });

            const locationTotals = Object.keys(counts).map(loc => ({
                name: loc,
                total: Object.values(counts[loc]).reduce((a, b) => a + b, 0)
            })).sort((a, b) => b.total - a.total).slice(0, 20);

            const locationLabels = locationTotals.map(l => l.name);
            const categoryLabels = [...new Set(data.map(item => item.categoria).filter(Boolean))].sort();
            
            const heatmapData = [];
            let maxValue = 0;
            locationLabels.forEach(loc => {
                categoryLabels.forEach(cat => {
                    const value = counts[loc]?.[cat] || 0;
                    if (value > 0) heatmapData.push({ x: cat, y: loc, v: value });
                    if (value > maxValue) maxValue = value;
                });
            });

            if (locationCategoryHeatmap) locationCategoryHeatmap.destroy();

            locationCategoryHeatmap = new Chart(ctx, {
                type: 'matrix',
                data: {
                    datasets: [{
                        label: 'Concentra√ß√£o',
                        data: heatmapData,
                        backgroundColor: (context) => {
                            const value = context.dataset.data[context.dataIndex]?.v;
                            if (!value) return 'rgba(245, 245, 245, 0.5)';
                            const alpha = Math.sqrt(value / maxValue);
                            return `rgba(1, 70, 92, ${alpha})`;
                        },
                        borderColor: 'white',
                        borderWidth: 1,
                        width: ({ chart }) => (chart.chartArea || {}).width / categoryLabels.length - 1,
                        height: ({ chart }) => (chart.chartArea || {}).height / locationLabels.length - 1,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { type: 'category', labels: categoryLabels, ticks: { autoSkip: false } },
                        y: { type: 'category', labels: locationLabels, offset: true, ticks: { autoSkip: false } }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: () => '',
                                label: (context) => {
                                    const v = context.dataset.data[context.dataIndex];
                                    return `${v.y} | ${v.x}: ${v.v} apontamentos`;
                                }
                            }
                        }
                    }
                }
            });
        };
        
        const showError = (message) => {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            document.getElementById('loading-container').style.display = 'none';
            document.getElementById('dashboard-content').style.display = 'none';
        };

        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) tabcontent[i].style.display = "none";
            tablinks = document.getElementsByClassName("tab-link");
            for (i = 0; i < tablinks.length; i++) tablinks[i].className = tablinks[i].className.replace(" active", "");
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            setTimeout(() => {
                const activeCharts = {
                    'visaoGeral': [histogramChart, monthlyResolutionRateChart, statusHistoryChart, detailsChart, heatmapChart],
                    'eficiencia': [resolutionScatterChart, slaByCategoryChart],
                    'localizacao': [groupingVolumeChart, locationRankingChart, locationCategoryHeatmap]
                }[tabName] || [];
                
                activeCharts.forEach(chart => {
                    if (chart) chart.resize();
                });
            }, 10);
        }
        
        function showDefectDetails(categoryName) {
            const categoryData = currentFinalData.filter(item => item.categoria === categoryName);
            const defectCounts = categoryData.reduce((acc, item) => {
                const defect = item.descricao || 'N√£o especificado';
                acc[defect] = (acc[defect] || 0) + 1;
                return acc;
            }, {});
            const sortedDefects = Object.entries(defectCounts)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 5);
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            modalTitle.textContent = `Top 5 Defeitos para: ${categoryName}`;
            if (sortedDefects.length === 0) {
                modalBody.innerHTML = '<p>Nenhum defeito espec√≠fico encontrado para esta categoria nos filtros atuais.</p>';
            } else {
                const listItems = sortedDefects.map(([defect, count]) => `<li><strong>${defect}</strong>: ${count} ocorr√™ncia(s)</li>`).join('');
                modalBody.innerHTML = `<ol>${listItems}</ol>`;
            }
            document.getElementById('modal-container').style.display = 'flex';
        }

        document.addEventListener('DOMContentLoaded', () => {
            // *** Chamada atualizada com o link CORRETO do Asset .jsonl da Release ***
            loadDefaultFile('https://github.com/FLUZ1/SnagR/releases/download/v1/PG44.jsonl');
            // #####################################################################

            const filterIds = [
                'spotted-filter', 'year-filter', 'month-filter', 'groupname-filter', 
                'categoria-filter', 'tipo-filter', 'descricao-filter', 
                'heatmap-year-filter', 'grouping-filter'
            ];
            filterIds.forEach(id => {
                document.getElementById(id)?.addEventListener('change', runUpdate);
            });

            document.getElementById('json-file-input').addEventListener('change', handleFileUpload);
            document.getElementById('print-button').addEventListener('click', () => { window.print(); });

            const body = document.body;
            const overlay = document.getElementById('drag-drop-overlay');
            let dragCounter = 0;
            body.addEventListener('dragenter', (e) => { e.preventDefault(); e.stopPropagation(); dragCounter++; overlay.style.display = 'flex'; });
            body.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); });
            body.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); dragCounter--; if (dragCounter === 0) { overlay.style.display = 'none'; } });
            body.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                overlay.style.display = 'none';
                dragCounter = 0;
                const files = e.dataTransfer.files;
                if (files && files.length > 0) { processFile(files[0]); }
            });
            
            const modalContainer = document.getElementById('modal-container');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalContent = document.getElementById('modal-content');
            const closeModal = () => modalContainer.style.display = 'none';
            modalCloseBtn.addEventListener('click', closeModal);
            modalContainer.addEventListener('click', (event) => { if (!modalContent.contains(event.target)) { closeModal(); } });
            
            let activeTabBeforePrint = 'visaoGeral';
            const allCharts = [histogramChart, monthlyResolutionRateChart, statusHistoryChart, detailsChart, heatmapChart, resolutionScatterChart, slaByCategoryChart, groupingVolumeChart, locationRankingChart, locationCategoryHeatmap];
            window.addEventListener('beforeprint', () => {
                const activeTabLink = document.querySelector('.tab-link.active');
                activeTabBeforePrint = activeTabLink.onclick.toString().match(/'([^']+)'/)[1];
                document.querySelectorAll('.tab-content').forEach(tab => { tab.style.display = 'block'; });
                allCharts.forEach(chart => { if (chart) chart.resize(); });
            });
            window.addEventListener('afterprint', () => {
                const activeLink = document.querySelector(`.tab-link[onclick*="'${activeTabBeforePrint}'"]`);
                openTab({ currentTarget: activeLink }, activeTabBeforePrint);
                allCharts.forEach(chart => { if (chart) chart.resize(); });
            });
        });
    </script>
</body>
</html>